#!/usr/local/bin/yog

from libc.file import read, write
from syslog import LOG_DEBUG, LOG_INFO, LOG_LOCAL0, LOG_PID, openlog, syslog

class BackupError > Exception
end

def log(msg, priority=LOG_INFO)
  syslog(priority, msg)
  return msg
end

def log_debug(msg)
  return log(msg, LOG_DEBUG)
end

def send(line)
  log("Send: {0}".format(line))
  print(line + "\r\n")
  STDOUT.flush()
end

def readline(line="")
  buf = Buffer.new(1)
  nbytes = read(0, buf, buf.size)
  if nbytes != buf.size
    raise Exception.new("read error")
  end
  c = buf.to_s(1, ENCODINGS["ascii"])
  if c == "\r"
    read(0, buf, buf.size) # "\n"
    return line
  end
  return readline(line + c)
end

def seek_next_param(line, pos)
  s = line.slice(pos)
  return (m = /\s+/.match(s)) == nil ? s : s.slice(m.end())
end

def get_next_token(line)
  if line[0] == "\""
    pos = 1
    txt = ""
    while (c = line[pos]) != "\""
      if c == "\\"
        txt << line[pos + 1]
        pos += 2
        next
      end
      txt << c
      pos += 1
    end
    return txt, seek_next_param(line, pos + 1)
  end
  if (m = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})T(?<hour>\d{2}):(?<minute>\d{2}):(?<second>\d{2}),(?<millisecond>\d{3})/.match(line)) != nil
    timestamp = Datetime.new(m.group("year").to_i(), m.group("month").to_i(), m.group("day").to_i(), m.group("hour").to_i(), m.group("minute").to_i(), m.group("second").to_i(), 1000 * m.group("millisecond").to_i())
    return timestamp, seek_next_param(line, m.end())
  end
  if (m = /\d+/.match(line)) != nil
    return m.group().to_i(), seek_next_param(line, m.end())
  end
  raise BackupError.new("Invalid parameter: {0}".format(line))
end

def parse_file(param)
  path, rest = get_next_token(param)
  mode, rest = get_next_token(rest)
  uid, rest = get_next_token(rest)
  gid, rest = get_next_token(rest)
  mtime, _ = get_next_token(rest)
  return path, mode, uid, gid, mtime
end

class Server
  def init(dest)
    self.dest = dest
    self.path = nil
  end

  def run()
    dir = self.dest / Datetime.new().to_iso8601()
    log("New backup: {0}".format(dir))
    make_dirs(dir)

    loop() do
      line = readline()
      log("Recv: {0}".format(line))
      self.act(dir, line)
    end
  end

  def do_file(path, mode, uid, gid, mtime)
    # TODO
    send("CHANGED")
    self.path = path
  end

  def do_body(dir, size)
    path = dir / self.path
    log("Write: {0}".format(path))
    File.open(path, "w") do [fp]
      rest = size
      while 0 < rest
        data = STDIN.read_binary(4096)
        fp.write(data)
        rest -= data.size
      end
    end
    send("OK")
  end

  def act(dir, line)
    if (m = line.match(/[A-Z]+/)) == nil
      raise BackupError.new("Invalid command: {0}".format(line))
    end
    cmd = m.group(0)
    if cmd == "DIR"
      # TODO
      send("OK")
      return
    end
    if cmd == "FILE"
      path, mode, uid, gid, mtime = parse_file(seek_next_param(line, m.end()))
      self.do_file(path, mode, uid, gid, mtime)
      return
    end
    if cmd == "BODY"
      self.do_body(dir, seek_next_param(line, m.end()).to_i())
      return
    end
    msg = "Unknown command: {0}".format(cmd)
    log(msg)
    raise BackupError.new(msg)
  end
end

if __FILE__ == ARGV.get(0)
  openlog(ARGV[0], LOG_PID, LOG_LOCAL0) do
    Server.new(ARGV[1].to_path()).run()
  end
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
