#!/usr/local/bin/yog

from libc.file import read, write
from syslog import LOG_DEBUG, LOG_INFO, LOG_LOCAL0, LOG_PID, openlog, syslog

class BackupError > Exception
end

def log(msg, priority=LOG_INFO)
  syslog(priority, msg)
  return msg
end

def log_debug(msg)
  return log(msg, LOG_DEBUG)
end

def send(line)
  log("Send: {0}".format(line))
  print(line + "\r\n")
  STDOUT.flush()
end

def readline(line="")
  buf = Buffer.new(1)
  nbytes = read(0, buf, buf.size)
  if nbytes != buf.size
    raise Exception.new("read error")
  end
  c = buf.to_s(1, ENCODINGS["ascii"])
  if c == "\r"
    read(0, buf, buf.size) # "\n"
    return line
  end
  return readline(line + c)
end

def seek_next_param(line, pos)
  s = line.slice(pos)
  return (m = /\s+/.match(s)) == nil ? s : s.slice(m.end())
end

def get_text_token(line)
  if line[0] != "\""
    raise SyntaxError.new(line)
  end
  pos = 1
  txt = ""
  while (c = line[pos]) != "\""
    if c == "\\"
      txt << line[pos + 1]
      pos += 2
      next
    end
    txt << c
    pos += 1
  end
  return txt, seek_next_param(line, pos + 1)
end

def parse_datetime(s)
  if (m = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})T(?<hour>\d{2}):(?<minute>\d{2}):(?<second>\d{2}),(?<millisecond>\d{3})/.match(s)) == nil
    return nil
  end
  return Datetime.new(m.group("year").to_i(), m.group("month").to_i(), m.group("day").to_i(), m.group("hour").to_i(), m.group("minute").to_i(), m.group("second").to_i(), 1000 * m.group("millisecond").to_i())
end

def parse_dir(param)
  path, rest = get_text_token(param)
  params = rest.split()
  mode = params[0].as_oct()
  uid = params[1].as_dec()
  gid = params[2].as_dec()
  return path.to_path(), mode, uid, gid
end

def get_decimal_token(s)
  if (m = /[0-9]+/.match(s)) == nil
    raise SyntaxError.new(s)
  end
  return m.group().as_dec(), seek_next_param(s, m.end())
end

def get_octal_token(s)
  if (m = /[0-7]+/.match(s)) == nil
    raise SyntaxError.new(s)
  end
  return m.group().as_oct(), seek_next_param(s, m.end())
end

def parse_symlink(param)
  path, rest = get_text_token(param)
  mode, rest = get_octal_token(rest)
  uid, rest = get_decimal_token(rest)
  gid, rest = get_decimal_token(rest)
  src, _ = get_text_token(rest)
  return path.to_path(), mode, uid, gid, src.to_path()
end

def parse_file(param)
  path, rest = get_text_token(param)
  params = rest.split()
  mode = params[0].as_oct()
  uid = params[1].as_dec()
  gid = params[2].as_dec()
  mtime = parse_datetime(params[3])
  return path.to_path(), mode, uid, gid, mtime
end

class Server
  def init(dest)
    self.dest = dest
    self.path = nil
  end

  def get_prev_dir(path)
    Dir.open(path) do [dir]
      latest = Datetime.new(1970, 1, 1, 0, 0, 0, 0)
      dir.each() do [name]
        timestamp = parse_datetime(name)
        if (timestamp != nil) && (latest < timestamp)
          latest = timestamp
        end
      end
      return path / latest.to_iso8601()
    end
  end

  def make_new_dir(dir)
    path = dir / Datetime.new().to_iso8601()
    log("New backup: {0}".format(path))
    self.make_meta_dir(path)
    return path
  end

  def run()
    make_dirs(self.dest / "meta")

    prev_dir = self.get_prev_dir(self.dest)
    dir = self.make_new_dir(self.dest)

    loop() do
      line = readline()
      log("Recv: {0}".format(line))
      if !self.act(dir, prev_dir, line)
        return
      end
    end
  end

  def make_meta_dir(dir)
    make_dirs(dir / ".meta")
  end

  def touch(path)
    File.open(path, "w") do
    end
  end

  def backup_meta_data(dir, path, mode, uid, gid)
    meta = dir + (path.dirname / ".meta" / (path.basename + ".meta"))
    src = self.dest / "meta" / "{0}-{1}-{2}".format(mode.to_s(8), uid, gid)
    log("Meta file: {0} -> {1}".format(meta, src))
    try
      meta.link_to(src)
    except SystemError
      self.touch(src)
      meta.link_to(src)
    end
  end

  def do_dir(dir, path, mode, uid, gid)
    self.backup_meta_data(dir, path, mode, uid, gid)
    s = dir + path
    self.make_meta_dir(s)
    make_dirs(s)
    send("OK")
  end

  def get_prev_mtime(path)
    try
      return path.lstat().mtime
    except SystemError
      return Datetime.new(1970, 1, 1, 0, 0, 0, 0)
    end
  end

  def do_symlink(dir, path, mode, uid, gid, src)
    self.backup_meta_data(dir, path, mode, uid, gid)
    dest = dir + path
    log("Symlink: {0} -> {1}".format(dest, src))
    dest.symlink_to(src)
    send("OK")
  end

  def do_file(dir, prev_dir, path, mode, uid, gid, mtime)
    self.backup_meta_data(dir, path, mode, uid, gid)

    prev_path = prev_dir + path
    if self.get_prev_mtime(prev_path) < mtime
      self.path = path
      send("CHANGED")
      return
    end
    (dir + path).link_to(prev_path)
    send("UNCHANGED")
  end

  def do_body(dir, size)
    path = dir + self.path
    log("Write: {0}".format(path))
    File.open(path, "w") do [fp]
      rest = size
      while 0 < rest
        max = 4096
        data = STDIN.read_binary(max < rest ? max : rest)
        fp.write(data)
        rest -= data.size
      end
    end
    send("OK")
  end

  def act(dir, prev_dir, line)
    if (m = line.match(/[A-Z_]+/)) == nil
      raise BackupError.new("Invalid command: {0}".format(line))
    end
    cmd = m.group(0)
    if cmd == "DIR"
      path, mode, uid, gid = parse_dir(seek_next_param(line, m.end()))
      self.do_dir(dir, path, mode, uid, gid)
      return true
    end
    if cmd == "FILE"
      path, mode, uid, gid, mtime = parse_file(seek_next_param(line, m.end()))
      self.do_file(dir, prev_dir, path, mode, uid, gid, mtime)
      return true
    end
    if cmd == "BODY"
      self.do_body(dir, seek_next_param(line, m.end()).to_i())
      return true
    end
    if cmd == "SYMLINK"
      path, mode, uid, gid, src = parse_symlink(seek_next_param(line, m.end()))
      self.do_symlink(dir, path, mode, uid, gid, src)
      return true
    end
    if cmd == "THANK_YOU"
      return false
    end
    msg = "Unknown command: {0}".format(cmd)
    log(msg)
    raise BackupError.new(msg)
  end
end

if __FILE__ == ARGV.get(0)
  openlog(ARGV[0], LOG_PID, LOG_LOCAL0) do
    Server.new(ARGV[1].to_path()).run()
  end
end

# vim: tabstop=2 shiftwidth=2 expandtab softtabstop=2
